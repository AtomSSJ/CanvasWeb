<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Canvas Colaborativo de Píxeles</title>
    <style>
        body {
            margin: 0; padding: 0; overflow: hidden;
            font-family: Arial, sans-serif; background-color: #f0f0f0;
        }
        #canvas-container {
            position: absolute; top: 0; left: 0;
            width: 100vw; height: 100vh; overflow: hidden;
        }
        #pixel-canvas { background-color: white; }

        /********** Paleta **********/
        #color-palette {
            position: fixed; top: 20px; left: 20px;
            width: 250px; padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            background: white;
            z-index: 100;
            transition: transform 0.3s;
        }
        /* Al ocultarla, la desplazamos casi toda a la izquierda */
        #color-palette.hidden {
            transform: translateX(-280px); 
            /* Ajusta este valor según el ancho total, para que solo se vea el handle */
        }

        /* Pequeño "handle" para mostrar/ocultar */
        #palette-handle {
            position: absolute; top: 0; right: -12px;
            width: 12px; height: 100%;
            background-color: #CCC; /* Un gris suave */
            border-top-right-radius: 8px;
            border-bottom-right-radius: 8px;
            cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            font-size: 14px; color: #333;
        }
        /* Flecha por defecto (cuando está visible) */
        #palette-handle::after {
            content: "❮";
        }
        /* Flecha cuando está oculto */
        #color-palette.hidden #palette-handle::after {
            content: "❯";
        }

        .color {
            width: 25px; height: 25px; cursor: pointer;
            border-radius: 4px; border: 2px solid transparent;
        }
        .color.selected { border: 2px solid #333; }

        /********** Controles **********/
        #controls {
            position: fixed; top: 20px; right: 20px;
            display: flex; flex-direction: column; gap: 10px;
            background-color: white; padding: 10px;
            border-radius: 8px; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            z-index: 100;
        }
        button {
            padding: 8px 12px; background-color: #4CAF50;
            color: white; border: none; cursor: pointer;
        }
        button:hover { background-color: #45a049; }

        #loading {
            position: fixed; top: 0; left: 0;
            width: 100vw; height: 100vh;
            background-color: rgba(255, 255, 255, 0.9);
            display: flex; justify-content: center; align-items: center;
            z-index: 1000;
        }
        .spinner {
            border: 5px solid #f3f3f3; border-top: 5px solid #3498db; border-radius: 50%;
            width: 50px; height: 50px; animation: spin 2s linear infinite;
        }
        @keyframes spin { 0% {transform: rotate(0deg);} 100% {transform: rotate(360deg);} }

        /* color-picker interno */
        #color-picker {
            display: flex; align-items: center; gap: 8px; margin-bottom: 10px;
        }
        #color-input {
            width: 40px; height: 40px; border: none; background: none; cursor: pointer;
        }
        #color-hex {
            width: 80px; padding: 5px; font-size: 14px; text-align: center;
            border: 1px solid #ccc; border-radius: 4px;
        }
        #color-slider-container { margin-bottom: 10px; }
        #color-slider {
            width: 100%; appearance: none; height: 5px;
            background: linear-gradient(to right, black, white); border-radius: 5px;
            outline: none; transition: opacity 0.2s;
        }
        #preset-colors {
            display: flex; flex-wrap: wrap; gap: 5px;
        }
        .color {
            width: 30px; height: 30px; border-radius: 4px; border: 2px solid transparent;
            cursor: pointer;
        }
        .color.selected { border: 2px solid #333; }

        /* Panel de usuario */
        #user-panel {
            position: fixed;
            top: 20px;
            right: 100px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            z-index: 100;
        }

        #user-balance {
            font-size: 18px;
            font-weight: bold;
            color: #4CAF50;
            margin-bottom: 10px;
        }

        /* Modal de confirmación */
        #purchase-modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            z-index: 1000;
        }

        #purchase-modal.active {
            display: block;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .modal-buttons button {
            flex: 1;
        }

        .modal-buttons button.cancel {
            background-color: #dc3545;
        }

        .modal-buttons button.cancel:hover {
            background-color: #c82333;
        }

        /* Información del píxel */
        .pixel-info {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="loading">
        <div class="spinner"></div>
        <p>Cargando canvas gigante...</p>
    </div>
    <div id="canvas-container">
        <canvas id="pixel-canvas"></canvas>
    </div>

    <!-- Paleta de colores -->
    <div id="color-palette">
        <div id="palette-handle"></div>
        
        <div id="color-picker">
            <input type="color" id="color-input">
            <input type="text" id="color-hex" maxlength="7">
        </div>
        <div id="color-slider-container">
            <input type="range" id="color-slider" min="0" max="100" value="50">
        </div>
        <div id="preset-colors">
            <div class="color" style="background-color: #000000;" data-color="#000000"></div>
            <div class="color" style="background-color: #FF0000;" data-color="#FF0000"></div>
            <div class="color" style="background-color: #00FF00;" data-color="#00FF00"></div>
            <div class="color" style="background-color: #0000FF;" data-color="#0000FF"></div>
            <div class="color" style="background-color: #FFFF00;" data-color="#FFFF00"></div>
            <div class="color" style="background-color: #FF00FF;" data-color="#FF00FF"></div>
            <div class="color" style="background-color: #00FFFF;" data-color="#00FFFF"></div>
            <div class="color" style="background-color: #FFA500;" data-color="#FFA500"></div>
        </div>
    </div>

    <!-- Panel de usuario -->
    <div id="user-panel">
        <div id="user-balance">Saldo: $<span id="balance-amount">1000</span></div>
        <div>Precio por píxel: $<span id="pixel-price">10</span></div>
    </div>

    <!-- Modal de confirmación de compra -->
    <div id="purchase-modal">
        <h3>Confirmar compra</h3>
        <p>¿Deseas comprar este píxel por $<span id="purchase-price">10</span>?</p>
        <p>Coordenadas: <span id="pixel-coords"></span></p>
        <div class="modal-buttons">
            <button id="confirm-purchase">Confirmar</button>
            <button class="cancel" id="cancel-purchase">Cancelar</button>
        </div>
    </div>

    <!-- Controles a la derecha -->
    <div id="controls">
        <button id="zoom-in">Zoom +</button>
        <button id="zoom-out">Zoom -</button>
        <button id="reset-view">Reset</button>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', function () {
        const canvas = document.getElementById('pixel-canvas');
        const ctx = canvas.getContext('2d');

        const zoomInButton = document.getElementById('zoom-in');
        const zoomOutButton = document.getElementById('zoom-out');
        const resetViewButton = document.getElementById('reset-view');
        const loadingScreen = document.getElementById('loading');

        const colorInput = document.getElementById("color-input");
        const colorHex = document.getElementById("color-hex");
        const colorSlider = document.getElementById("color-slider");
        const presetColors = document.querySelectorAll(".color");

        // Paleta y handle
        const colorPaletteDiv = document.getElementById('color-palette');
        const paletteHandle = document.getElementById('palette-handle');

        // Tamaño del canvas
        const CANVAS_SIZE = 10000;
        const PIXEL_SIZE = 5;
        const MAX_INDEX = CANVAS_SIZE / PIXEL_SIZE;

        // Zoom y desplazamiento
        let zoomLevel = 1;
        let offsetX = 0;
        let offsetY = 0;

        // Configuración de zoom: valores mínimo y máximo
        // minZoom = calculamos en función del tamaño de la ventana para ver todo el lienzo
        // maxZoom = un límite arbitrario (p.ej. 10)
        let minZoom = 0.1; // Se redefinirá tras el DOMLoaded
        const maxZoom = 10;

        // Manejo de clicks / arrastre
        let isMouseDown = false;
        let mouseMoved = false; 
        let lastMouseX = 0, lastMouseY = 0;
        let isShiftPressed = false;
        let selectionStart = null;
        let selectionEnd = null;
        let isDragging = false;
        let selectedRegion = null;

        // Diccionario para colores de píxeles
        let pixels = {};
        
        // Diccionario para regiones compradas
        let purchasedRegions = [];

        // Sistema de compra
        let userBalance = 1000;  // Saldo inicial
        const PIXEL_PRICE = 10;  // Precio por píxel
        let pendingPurchase = null;

        // Referencias a elementos del DOM para el sistema de compra
        const userPanel = document.getElementById('user-panel');
        const balanceAmount = document.getElementById('balance-amount');
        const purchaseModal = document.getElementById('purchase-modal');
        const confirmPurchaseBtn = document.getElementById('confirm-purchase');
        const cancelPurchaseBtn = document.getElementById('cancel-purchase');
        const pixelCoordsSpan = document.getElementById('pixel-coords');

        // Datos para HSL
        let baseHSL = { h: 0, s: 0, l: 50 };

        // Ajusta dimensiones del canvas
        canvas.width = CANVAS_SIZE;
        canvas.height = CANVAS_SIZE;

        //---------------------------------------------------
        // Función para calcular el zoom mínimo (ver todo)
        //---------------------------------------------------
        function calcMinZoom() {
            // Comparar el ratio de ancho y alto con respecto al CANVAS_SIZE
            const ratioW = window.innerWidth / CANVAS_SIZE;
            const ratioH = window.innerHeight / CANVAS_SIZE;
            // El menor de estos dos asegura que se vea TODO el canvas en ambas dimensiones
            return Math.min(ratioW, ratioH);
        }

        //---------------------------------------------------
        // Función para centrar el canvas con el zoom actual
        //---------------------------------------------------
        function centerCanvas() {
            const visibleWidth = CANVAS_SIZE * zoomLevel;
            const visibleHeight = CANVAS_SIZE * zoomLevel;

            offsetX = (window.innerWidth - visibleWidth) / 2;
            offsetY = (window.innerHeight - visibleHeight) / 2;
        }

        /******************************************************
         * Conversión HEX <-> HSL
         ******************************************************/
        function hexToHSL(hex) {
            let r = parseInt(hex.substring(1, 3), 16) / 255;
            let g = parseInt(hex.substring(3, 5), 16) / 255;
            let b = parseInt(hex.substring(5, 7), 16) / 255;

            let max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0;
            } else {
                let d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h = Math.round(h * 60);
            }
            return { h, s: Math.round(s * 100), l: Math.round(l * 100) };
        }

        function hslToHex(h, s, l) {
            s /= 100;
            l /= 100;
            let c = (1 - Math.abs(2 * l - 1)) * s;
            let x = c * (1 - Math.abs((h / 60) % 2 - 1));
            let m = l - c / 2;
            let r, g, b;

            if (0 <= h && h < 60) { r = c; g = x; b = 0; }
            else if (60 <= h && h < 120) { r = x; g = c; b = 0; }
            else if (120 <= h && h < 180) { r = 0; g = c; b = x; }
            else if (180 <= h && h < 240) { r = 0; g = x; b = c; }
            else if (240 <= h && h < 300) { r = x; g = 0; b = c; }
            else { r = c; g = 0; b = x; }

            return `#${(
                (1 << 24) +
                ((Math.round((r + m) * 255) << 16)) +
                ((Math.round((g + m) * 255) << 8)) +
                Math.round((b + m) * 255)
            ).toString(16).slice(1).toUpperCase()}`;
        }
        /******************************************************/

        //---------------------------------------------------
        // Dibuja la cuadrícula
        //---------------------------------------------------
        function drawGrid() {
            ctx.strokeStyle = "#ddd";
            for (let x = 0; x < CANVAS_SIZE; x += PIXEL_SIZE) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, CANVAS_SIZE);
                ctx.stroke();
            }
            for (let y = 0; y < CANVAS_SIZE; y += PIXEL_SIZE) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(CANVAS_SIZE, y);
                ctx.stroke();
            }
        }

        //---------------------------------------------------
        // Redibuja en el canvas con la transformación actual
        //---------------------------------------------------
        function updateCanvas() {
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.translate(offsetX, offsetY);
            ctx.scale(zoomLevel, zoomLevel);

            drawGrid();

            // Dibujar regiones compradas con borde
            purchasedRegions.forEach(region => {
                ctx.strokeStyle = '#4CAF50';
                ctx.lineWidth = 2;
                ctx.strokeRect(
                    region.minX * PIXEL_SIZE,
                    region.minY * PIXEL_SIZE,
                    (region.maxX - region.minX + 1) * PIXEL_SIZE,
                    (region.maxY - region.minY + 1) * PIXEL_SIZE
                );
            });

            // Dibujar píxeles
            for (const key in pixels) {
                const [px, py] = key.split(',').map(Number);
                ctx.fillStyle = pixels[key];
                ctx.fillRect(px * PIXEL_SIZE, py * PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE);
            }

            // Dibujar selección actual si existe
            if (isShiftPressed && selectionStart) {
                drawSelection();
            }
        }

        //---------------------------------------------------
        // Selección de color y brillo
        //---------------------------------------------------
        function updateSelectedColor(color) {
            baseHSL = hexToHSL(color);
            colorSlider.value = baseHSL.l;
            applyBrightness();

            colorInput.value = color;
            colorHex.value = color.toUpperCase();
            document.querySelector(".color.selected")?.classList.remove("selected");
        }

        function applyBrightness() {
            const newColor = hslToHex(baseHSL.h, baseHSL.s, colorSlider.value);
            colorInput.value = newColor;
            colorHex.value = newColor.toUpperCase();
            selectedColor = newColor;
        }

        colorInput.addEventListener("input", (e) => updateSelectedColor(e.target.value));
        colorHex.addEventListener("input", (e) => {
            if (/^#[0-9A-F]{6}$/i.test(e.target.value)) {
                updateSelectedColor(e.target.value);
            }
        });
        presetColors.forEach(colorDiv => {
            colorDiv.addEventListener("click", () => {
                updateSelectedColor(colorDiv.getAttribute("data-color"));
                colorDiv.classList.add("selected");
            });
        });
        colorSlider.addEventListener("input", applyBrightness);
        updateSelectedColor("#000000"); // color inicial

        //---------------------------------------------------
        // Eventos de mouse para dibujar vs arrastrar
        //---------------------------------------------------
        canvas.addEventListener("mousedown", function (e) {
            if (e.button === 0) {
                isMouseDown = true;
                mouseMoved = false;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                
                if (isShiftPressed) {
                    const rect = canvas.getBoundingClientRect();
                    const x = Math.floor((e.clientX - rect.left - offsetX) / (zoomLevel * PIXEL_SIZE));
                    const y = Math.floor((e.clientY - rect.top - offsetY) / (zoomLevel * PIXEL_SIZE));
                    selectionStart = [x, y];
                    selectionEnd = [x, y];
                } else {
                    canvas.style.cursor = "grabbing";
                    isDragging = true;
                }
            }
        });

        canvas.addEventListener("mousemove", function (e) {
            if (!isMouseDown) return;

            if (isShiftPressed && selectionStart) {
                const rect = canvas.getBoundingClientRect();
                const x = Math.floor((e.clientX - rect.left - offsetX) / (zoomLevel * PIXEL_SIZE));
                const y = Math.floor((e.clientY - rect.top - offsetY) / (zoomLevel * PIXEL_SIZE));
                selectionEnd = [x, y];
                updateCanvas();
            } else if (isDragging) {
                const dx = e.clientX - lastMouseX;
                const dy = e.clientY - lastMouseY;

                if (Math.abs(dx) > 3 || Math.abs(dy) > 3) {
                    mouseMoved = true;
                }

                offsetX += dx;
                offsetY += dy;

                lastMouseX = e.clientX;
                lastMouseY = e.clientY;

                updateCanvas();
            }
        });

        canvas.addEventListener("mouseup", function (e) {
            if (e.button === 0) {
                if (!isShiftPressed && !mouseMoved) {
                    paintPixel(e);
                }
                isMouseDown = false;
                isDragging = false;
                canvas.style.cursor = isShiftPressed ? "crosshair" : "default";
            }
        });

        canvas.addEventListener("mouseleave", function () {
            isMouseDown = false;
            canvas.style.cursor = "default";
        });

        function paintPixel(e) {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left - offsetX) / (zoomLevel * PIXEL_SIZE));
            const y = Math.floor((e.clientY - rect.top - offsetY) / (zoomLevel * PIXEL_SIZE));

            if (x < 0 || x >= MAX_INDEX || y < 0 || y >= MAX_INDEX) {
                return; // fuera de rango
            }

            // Verificar si el píxel está en una región comprada
            if (!isInPurchasedRegion(x, y)) {
                alert('Solo puedes dibujar en regiones que hayas comprado');
                return;
            }

            // Pintar el píxel directamente sin confirmación
            const key = `${x},${y}`;
            pixels[key] = selectedColor;
            updateCanvas();
        }

        //---------------------------------------------------
        // Zoom con botones y rueda
        //---------------------------------------------------
        zoomInButton.addEventListener("click", function () {
            const newZoom = Math.min(zoomLevel * 1.2, maxZoom);
            zoomLevel = newZoom;
            updateCanvas();
        });

        zoomOutButton.addEventListener("click", function () {
            // Impedimos que baje de minZoom
            const newZoom = Math.max(zoomLevel / 1.2, minZoom);
            zoomLevel = newZoom;
            updateCanvas();
        });

        // Botón reset: mostrar todo el canvas y centrarlo
        resetViewButton.addEventListener("click", function () {
            zoomLevel = minZoom;  // define el zoom mínimo
            centerCanvas();       // centrar en la pantalla
            updateCanvas();
        });

        // Zoom con rueda del ratón, también limitado
        canvas.addEventListener("wheel", function (event) {
            event.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;

            // Coordenadas en espacio de "canvas"
            const canvasX = (mouseX - offsetX) / zoomLevel;
            const canvasY = (mouseY - offsetY) / zoomLevel;

            // Aumenta o disminuye en un factor
            let newZoom = zoomLevel * (event.deltaY < 0 ? 1.1 : 0.9);

            // Limitamos entre minZoom y maxZoom
            newZoom = Math.max(minZoom, Math.min(newZoom, maxZoom));

            // Ajustamos offset para que el zoom sea "hacia el puntero"
            offsetX = mouseX - canvasX * newZoom;
            offsetY = mouseY - canvasY * newZoom;

            zoomLevel = newZoom;
            updateCanvas();
        });

        //---------------------------------------------------
        // Handle para ocultar/mostrar la paleta
        //---------------------------------------------------
        paletteHandle.addEventListener("click", function () {
            colorPaletteDiv.classList.toggle('hidden');
        });

        //---------------------------------------------------
        // Al cargar, calculamos minZoom, centramos y dibujamos
        //---------------------------------------------------
        setTimeout(() => {
            loadingScreen.style.display = "none";

            // Calculamos el zoom mínimo para que quepa todo el canvas
            minZoom = calcMinZoom();

            // Empezamos en ese nivel de zoom y centramos
            zoomLevel = minZoom;
            centerCanvas();
            
            updateCanvas();
        }, 1000);

        // Función para actualizar el saldo mostrado
        function updateBalance() {
            balanceAmount.textContent = userBalance;
        }

        // Función para mostrar información del píxel al pasar el mouse
        function showPixelInfo(x, y) {
            // Primero eliminamos cualquier tooltip existente
            hidePixelInfo();
            
            const key = `${x},${y}`;
            if (pixelOwners[key]) {
                const info = document.createElement('div');
                info.className = 'pixel-info';
                info.textContent = `Propietario: ${pixelOwners[key]}`;
                info.style.left = `${event.clientX + 10}px`;
                info.style.top = `${event.clientY + 10}px`;
                document.body.appendChild(info);
            }
        }

        // Función para ocultar información del píxel
        function hidePixelInfo() {
            const tooltips = document.querySelectorAll('.pixel-info');
            tooltips.forEach(tooltip => tooltip.remove());
        }

        // Evento para confirmar la compra
        confirmPurchaseBtn.addEventListener('click', function() {
            if (pixelsToPurchase.size > 0) {
                const totalPrice = pixelsToPurchase.size * PIXEL_PRICE;
                
                if (userBalance >= totalPrice) {
                    userBalance -= totalPrice;
                    
                    // Aplicar todas las compras
                    for (const key of pixelsToPurchase) {
                        pixels[key] = selectedColor;
                        pixelOwners[key] = 'Usuario';
                    }
                    
                    updateBalance();
                    updateCanvas();
                    pixelsToPurchase.clear();
                } else {
                    alert('No tienes suficiente saldo para comprar estos píxeles');
                }
            } else if (pendingPurchase) {
                // Compra individual original
                if (userBalance >= PIXEL_PRICE) {
                    const { x, y } = pendingPurchase;
                    const key = `${x},${y}`;
                    
                    userBalance -= PIXEL_PRICE;
                    pixels[key] = selectedColor;
                    pixelOwners[key] = 'Usuario';
                    
                    updateBalance();
                    updateCanvas();
                }
            }
            
            purchaseModal.classList.remove('active');
            pendingPurchase = null;
        });

        // Evento para cancelar la compra
        cancelPurchaseBtn.addEventListener('click', function() {
            purchaseModal.classList.remove('active');
            pendingPurchase = null;
            pixelsToPurchase.clear();
            updateCanvas();
        });

        // Agregar eventos para mostrar información del píxel
        canvas.addEventListener('mousemove', function(e) {
            if (!isMouseDown) {
                const rect = canvas.getBoundingClientRect();
                const x = Math.floor((e.clientX - rect.left - offsetX) / (zoomLevel * PIXEL_SIZE));
                const y = Math.floor((e.clientY - rect.top - offsetY) / (zoomLevel * PIXEL_SIZE));
                
                if (x >= 0 && x < MAX_INDEX && y >= 0 && y < MAX_INDEX) {
                    showPixelInfo(x, y);
                } else {
                    hidePixelInfo();
                }
            } else {
                hidePixelInfo();
            }
        });

        canvas.addEventListener('mouseleave', hidePixelInfo);
        canvas.addEventListener('mousedown', hidePixelInfo);

        // Modificar los event listeners existentes
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Shift') {
                isShiftPressed = true;
                canvas.style.cursor = 'crosshair';
            }
        });

        document.addEventListener('keyup', function(e) {
            if (e.key === 'Shift') {
                isShiftPressed = false;
                canvas.style.cursor = 'default';
                if (pixelsToPurchase.size > 0) {
                    updatePurchaseModal();
                    purchaseModal.classList.add('active');
                }
            }
        });

        // Función para actualizar el modal de compra múltiple
        function updatePurchaseModal() {
            const totalPrice = pixelsToPurchase.size * PIXEL_PRICE;
            const modalTitle = document.querySelector('#purchase-modal h3');
            const modalText = document.querySelector('#purchase-modal p');
            const coordsText = document.querySelector('#pixel-coords');

            modalTitle.textContent = 'Confirmar compra múltiple';
            modalText.textContent = `¿Deseas comprar ${pixelsToPurchase.size} píxeles por $${totalPrice}?`;
            coordsText.textContent = `Cantidad de píxeles: ${pixelsToPurchase.size}`;
        }

        // Función para dibujar la selección de región
        function drawSelection() {
            if (selectionStart && selectionEnd) {
                const [startX, startY] = selectionStart;
                const [endX, endY] = selectionEnd;
                
                const minX = Math.min(startX, endX);
                const maxX = Math.max(startX, endX);
                const minY = Math.min(startY, endY);
                const maxY = Math.max(startY, endY);
                
                ctx.save();
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                
                ctx.strokeRect(
                    minX * PIXEL_SIZE,
                    minY * PIXEL_SIZE,
                    (maxX - minX + 1) * PIXEL_SIZE,
                    (maxY - minY + 1) * PIXEL_SIZE
                );
                
                // Mostrar área seleccionada semi-transparente
                ctx.fillStyle = 'rgba(0, 255, 0, 0.2)';
                ctx.fillRect(
                    minX * PIXEL_SIZE,
                    minY * PIXEL_SIZE,
                    (maxX - minX + 1) * PIXEL_SIZE,
                    (maxY - minY + 1) * PIXEL_SIZE
                );
                
                ctx.restore();
            }
        }

        // Función para verificar si un punto está dentro de una región comprada
        function isInPurchasedRegion(x, y) {
            return purchasedRegions.some(region => {
                return x >= region.minX && x <= region.maxX &&
                       y >= region.minY && y <= region.maxY;
            });
        }

        // Función para verificar si una nueva región se superpone con las existentes
        function doesRegionOverlap(minX, minY, maxX, maxY) {
            return purchasedRegions.some(region => {
                return !(maxX < region.minX || minX > region.maxX ||
                        maxY < region.minY || minY > region.maxY);
            });
        }

        // Función para calcular el precio de una región
        function calculateRegionPrice(minX, minY, maxX, maxY) {
            const width = maxX - minX + 1;
            const height = maxY - minY + 1;
            return width * height * PIXEL_PRICE;
        }

        // Modificar el evento keyup para manejar la compra de región
        document.addEventListener('keyup', function(e) {
            if (e.key === 'Shift' && selectionStart && selectionEnd) {
                isShiftPressed = false;
                canvas.style.cursor = 'default';

                const [startX, startY] = selectionStart;
                const [endX, endY] = selectionEnd;
                
                const minX = Math.min(startX, endX);
                const maxX = Math.max(startX, endX);
                const minY = Math.min(startY, endY);
                const maxY = Math.max(startY, endY);

                // Verificar superposición
                if (doesRegionOverlap(minX, minY, maxX, maxY)) {
                    alert('Esta región se superpone con una región ya comprada');
                    selectionStart = null;
                    selectionEnd = null;
                    updateCanvas();
                    return;
                }

                const price = calculateRegionPrice(minX, minY, maxX, maxY);
                
                if (userBalance >= price) {
                    if (confirm(`¿Deseas comprar esta región por $${price}?`)) {
                        userBalance -= price;
                        purchasedRegions.push({ minX, minY, maxX, maxY });
                        updateBalance();
                    }
                } else {
                    alert('No tienes suficiente saldo para comprar esta región');
                }

                selectionStart = null;
                selectionEnd = null;
                updateCanvas();
            }
        });

        document.addEventListener('keydown', function(e) {
            if (e.key === 'Shift') {
                isShiftPressed = true;
                canvas.style.cursor = 'crosshair';
            }
        });
    });
    </script>
</body>
</html>
