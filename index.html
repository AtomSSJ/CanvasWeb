<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Canvas Colaborativo de Píxeles</title>
    <style>
        body {
            margin: 0; padding: 0; overflow: hidden;
            font-family: Arial, sans-serif; background-color: #f0f0f0;
        }
        #canvas-container {
            position: absolute; top: 0; left: 0;
            width: 100vw; height: 100vh; overflow: hidden;
        }
        #pixel-canvas { background-color: white; }

        /********** Paleta **********/
        #color-palette {
            position: fixed; top: 20px; left: 20px;
            width: 250px; padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            background: white;
            z-index: 100;
            transition: transform 0.3s;
        }
        /* Al ocultarla, la desplazamos casi toda a la izquierda */
        #color-palette.hidden {
            transform: translateX(-280px); 
            /* Ajusta este valor según el ancho total, para que solo se vea el handle */
        }

        /* Pequeño “handle” para mostrar/ocultar */
        #palette-handle {
            position: absolute; top: 0; right: -12px;
            width: 12px; height: 100%;
            background-color: #CCC; /* Un gris suave */
            border-top-right-radius: 8px;
            border-bottom-right-radius: 8px;
            cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            font-size: 14px; color: #333;
        }
        /* Flecha por defecto (cuando está visible) */
        #palette-handle::after {
            content: "❮";
        }
        /* Flecha cuando está oculto */
        #color-palette.hidden #palette-handle::after {
            content: "❯";
        }

        .color {
            width: 25px; height: 25px; cursor: pointer;
            border-radius: 4px; border: 2px solid transparent;
        }
        .color.selected { border: 2px solid #333; }

        /********** Controles **********/
        #controls {
            position: fixed; top: 20px; right: 20px;
            display: flex; flex-direction: column; gap: 10px;
            background-color: white; padding: 10px;
            border-radius: 8px; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            z-index: 100;
        }
        button {
            padding: 8px 12px; background-color: #4CAF50;
            color: white; border: none; cursor: pointer;
        }
        button:hover { background-color: #45a049; }

        #loading {
            position: fixed; top: 0; left: 0;
            width: 100vw; height: 100vh;
            background-color: rgba(255, 255, 255, 0.9);
            display: flex; justify-content: center; align-items: center;
            z-index: 1000;
        }
        .spinner {
            border: 5px solid #f3f3f3; border-top: 5px solid #3498db; border-radius: 50%;
            width: 50px; height: 50px; animation: spin 2s linear infinite;
        }
        @keyframes spin { 0% {transform: rotate(0deg);} 100% {transform: rotate(360deg);} }

        /* color-picker interno */
        #color-picker {
            display: flex; align-items: center; gap: 8px; margin-bottom: 10px;
        }
        #color-input {
            width: 40px; height: 40px; border: none; background: none; cursor: pointer;
        }
        #color-hex {
            width: 80px; padding: 5px; font-size: 14px; text-align: center;
            border: 1px solid #ccc; border-radius: 4px;
        }
        #color-slider-container { margin-bottom: 10px; }
        #color-slider {
            width: 100%; appearance: none; height: 5px;
            background: linear-gradient(to right, black, white); border-radius: 5px;
            outline: none; transition: opacity 0.2s;
        }
        #preset-colors {
            display: flex; flex-wrap: wrap; gap: 5px;
        }
        .color {
            width: 30px; height: 30px; border-radius: 4px; border: 2px solid transparent;
            cursor: pointer;
        }
        .color.selected { border: 2px solid #333; }
    </style>
</head>
<body>
    <div id="loading">
        <div class="spinner"></div>
        <p>Cargando canvas gigante...</p>
    </div>
    <div id="canvas-container">
        <canvas id="pixel-canvas"></canvas>
    </div>

    <!-- Paleta de colores -->
    <div id="color-palette">
        <div id="palette-handle"></div>
        
        <div id="color-picker">
            <input type="color" id="color-input">
            <input type="text" id="color-hex" maxlength="7">
        </div>
        <div id="color-slider-container">
            <input type="range" id="color-slider" min="0" max="100" value="50">
        </div>
        <div id="preset-colors">
            <div class="color" style="background-color: #000000;" data-color="#000000"></div>
            <div class="color" style="background-color: #FF0000;" data-color="#FF0000"></div>
            <div class="color" style="background-color: #00FF00;" data-color="#00FF00"></div>
            <div class="color" style="background-color: #0000FF;" data-color="#0000FF"></div>
            <div class="color" style="background-color: #FFFF00;" data-color="#FFFF00"></div>
            <div class="color" style="background-color: #FF00FF;" data-color="#FF00FF"></div>
            <div class="color" style="background-color: #00FFFF;" data-color="#00FFFF"></div>
            <div class="color" style="background-color: #FFA500;" data-color="#FFA500"></div>
        </div>
    </div>

    <!-- Controles a la derecha -->
    <div id="controls">
        <button id="zoom-in">Zoom +</button>
        <button id="zoom-out">Zoom -</button>
        <button id="reset-view">Reset</button>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', function () {
        const canvas = document.getElementById('pixel-canvas');
        const ctx = canvas.getContext('2d');

        const zoomInButton = document.getElementById('zoom-in');
        const zoomOutButton = document.getElementById('zoom-out');
        const resetViewButton = document.getElementById('reset-view');
        const loadingScreen = document.getElementById('loading');

        const colorInput = document.getElementById("color-input");
        const colorHex = document.getElementById("color-hex");
        const colorSlider = document.getElementById("color-slider");
        const presetColors = document.querySelectorAll(".color");

        // Paleta y handle
        const colorPaletteDiv = document.getElementById('color-palette');
        const paletteHandle = document.getElementById('palette-handle');

        // Tamaño del canvas
        const CANVAS_SIZE = 10000;
        const PIXEL_SIZE = 5;
        const MAX_INDEX = CANVAS_SIZE / PIXEL_SIZE;

        // Zoom y desplazamiento
        let zoomLevel = 1;
        let offsetX = 0;
        let offsetY = 0;

        // Configuración de zoom: valores mínimo y máximo
        // minZoom = calculamos en función del tamaño de la ventana para ver todo el lienzo
        // maxZoom = un límite arbitrario (p.ej. 10)
        let minZoom = 0.1; // Se redefinirá tras el DOMLoaded
        const maxZoom = 10;

        // Manejo de clicks / arrastre
        let isMouseDown = false;
        let mouseMoved = false; 
        let lastMouseX = 0, lastMouseY = 0;

        // Diccionario para colores de píxeles
        let pixels = {};

        // Datos para HSL
        let baseHSL = { h: 0, s: 0, l: 50 };

        // Ajusta dimensiones del canvas
        canvas.width = CANVAS_SIZE;
        canvas.height = CANVAS_SIZE;

        //---------------------------------------------------
        // Función para calcular el zoom mínimo (ver todo)
        //---------------------------------------------------
        function calcMinZoom() {
            // Comparar el ratio de ancho y alto con respecto al CANVAS_SIZE
            const ratioW = window.innerWidth / CANVAS_SIZE;
            const ratioH = window.innerHeight / CANVAS_SIZE;
            // El menor de estos dos asegura que se vea TODO el canvas en ambas dimensiones
            return Math.min(ratioW, ratioH);
        }

        //---------------------------------------------------
        // Función para centrar el canvas con el zoom actual
        //---------------------------------------------------
        function centerCanvas() {
            const visibleWidth = CANVAS_SIZE * zoomLevel;
            const visibleHeight = CANVAS_SIZE * zoomLevel;

            offsetX = (window.innerWidth - visibleWidth) / 2;
            offsetY = (window.innerHeight - visibleHeight) / 2;
        }

        /******************************************************
         * Conversión HEX <-> HSL
         ******************************************************/
        function hexToHSL(hex) {
            let r = parseInt(hex.substring(1, 3), 16) / 255;
            let g = parseInt(hex.substring(3, 5), 16) / 255;
            let b = parseInt(hex.substring(5, 7), 16) / 255;

            let max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0;
            } else {
                let d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h = Math.round(h * 60);
            }
            return { h, s: Math.round(s * 100), l: Math.round(l * 100) };
        }

        function hslToHex(h, s, l) {
            s /= 100;
            l /= 100;
            let c = (1 - Math.abs(2 * l - 1)) * s;
            let x = c * (1 - Math.abs((h / 60) % 2 - 1));
            let m = l - c / 2;
            let r, g, b;

            if (0 <= h && h < 60) { r = c; g = x; b = 0; }
            else if (60 <= h && h < 120) { r = x; g = c; b = 0; }
            else if (120 <= h && h < 180) { r = 0; g = c; b = x; }
            else if (180 <= h && h < 240) { r = 0; g = x; b = c; }
            else if (240 <= h && h < 300) { r = x; g = 0; b = c; }
            else { r = c; g = 0; b = x; }

            return `#${(
                (1 << 24) +
                ((Math.round((r + m) * 255) << 16)) +
                ((Math.round((g + m) * 255) << 8)) +
                Math.round((b + m) * 255)
            ).toString(16).slice(1).toUpperCase()}`;
        }
        /******************************************************/

        //---------------------------------------------------
        // Dibuja la cuadrícula
        //---------------------------------------------------
        function drawGrid() {
            ctx.strokeStyle = "#ddd";
            for (let x = 0; x < CANVAS_SIZE; x += PIXEL_SIZE) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, CANVAS_SIZE);
                ctx.stroke();
            }
            for (let y = 0; y < CANVAS_SIZE; y += PIXEL_SIZE) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(CANVAS_SIZE, y);
                ctx.stroke();
            }
        }

        //---------------------------------------------------
        // Redibuja en el canvas con la transformación actual
        //---------------------------------------------------
        function updateCanvas() {
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.translate(offsetX, offsetY);
            ctx.scale(zoomLevel, zoomLevel);

            drawGrid();

            for (const key in pixels) {
                const [px, py] = key.split(',').map(Number);
                ctx.fillStyle = pixels[key];
                ctx.fillRect(px * PIXEL_SIZE, py * PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE);
            }
        }

        //---------------------------------------------------
        // Selección de color y brillo
        //---------------------------------------------------
        function updateSelectedColor(color) {
            baseHSL = hexToHSL(color);
            colorSlider.value = baseHSL.l;
            applyBrightness();

            colorInput.value = color;
            colorHex.value = color.toUpperCase();
            document.querySelector(".color.selected")?.classList.remove("selected");
        }

        function applyBrightness() {
            const newColor = hslToHex(baseHSL.h, baseHSL.s, colorSlider.value);
            colorInput.value = newColor;
            colorHex.value = newColor.toUpperCase();
            selectedColor = newColor;
        }

        colorInput.addEventListener("input", (e) => updateSelectedColor(e.target.value));
        colorHex.addEventListener("input", (e) => {
            if (/^#[0-9A-F]{6}$/i.test(e.target.value)) {
                updateSelectedColor(e.target.value);
            }
        });
        presetColors.forEach(colorDiv => {
            colorDiv.addEventListener("click", () => {
                updateSelectedColor(colorDiv.getAttribute("data-color"));
                colorDiv.classList.add("selected");
            });
        });
        colorSlider.addEventListener("input", applyBrightness);
        updateSelectedColor("#000000"); // color inicial

        //---------------------------------------------------
        // Eventos de mouse para dibujar vs arrastrar
        //---------------------------------------------------
        canvas.addEventListener("mousedown", function (e) {
            if (e.button === 0) {
                isMouseDown = true;
                mouseMoved = false;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                canvas.style.cursor = "grabbing";
            }
        });

        canvas.addEventListener("mousemove", function (e) {
            if (!isMouseDown) return;

            const dx = e.clientX - lastMouseX;
            const dy = e.clientY - lastMouseY;

            // Umbral de movimiento
            if (Math.abs(dx) > 3 || Math.abs(dy) > 3) {
                mouseMoved = true;
            }

            offsetX += dx;
            offsetY += dy;

            lastMouseX = e.clientX;
            lastMouseY = e.clientY;

            updateCanvas();
        });

        canvas.addEventListener("mouseup", function (e) {
            if (e.button === 0) {
                canvas.style.cursor = "default";
                if (!mouseMoved) {
                    paintPixel(e);
                }
                isMouseDown = false;
            }
        });

        canvas.addEventListener("mouseleave", function () {
            isMouseDown = false;
            canvas.style.cursor = "default";
        });

        function paintPixel(e) {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left - offsetX) / (zoomLevel * PIXEL_SIZE));
            const y = Math.floor((e.clientY - rect.top - offsetY) / (zoomLevel * PIXEL_SIZE));

            if (x < 0 || x >= MAX_INDEX || y < 0 || y >= MAX_INDEX) {
                return; // fuera de rango
            }
            pixels[`${x},${y}`] = selectedColor;
            updateCanvas();
        }

        //---------------------------------------------------
        // Zoom con botones y rueda
        //---------------------------------------------------
        zoomInButton.addEventListener("click", function () {
            const newZoom = Math.min(zoomLevel * 1.2, maxZoom);
            zoomLevel = newZoom;
            updateCanvas();
        });

        zoomOutButton.addEventListener("click", function () {
            // Impedimos que baje de minZoom
            const newZoom = Math.max(zoomLevel / 1.2, minZoom);
            zoomLevel = newZoom;
            updateCanvas();
        });

        // Botón reset: mostrar todo el canvas y centrarlo
        resetViewButton.addEventListener("click", function () {
            zoomLevel = minZoom;  // define el zoom mínimo
            centerCanvas();       // centrar en la pantalla
            updateCanvas();
        });

        // Zoom con rueda del ratón, también limitado
        canvas.addEventListener("wheel", function (event) {
            event.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;

            // Coordenadas en espacio de "canvas"
            const canvasX = (mouseX - offsetX) / zoomLevel;
            const canvasY = (mouseY - offsetY) / zoomLevel;

            // Aumenta o disminuye en un factor
            let newZoom = zoomLevel * (event.deltaY < 0 ? 1.1 : 0.9);

            // Limitamos entre minZoom y maxZoom
            newZoom = Math.max(minZoom, Math.min(newZoom, maxZoom));

            // Ajustamos offset para que el zoom sea "hacia el puntero"
            offsetX = mouseX - canvasX * newZoom;
            offsetY = mouseY - canvasY * newZoom;

            zoomLevel = newZoom;
            updateCanvas();
        });

        //---------------------------------------------------
        // Handle para ocultar/mostrar la paleta
        //---------------------------------------------------
        paletteHandle.addEventListener("click", function () {
            colorPaletteDiv.classList.toggle('hidden');
        });

        //---------------------------------------------------
        // Al cargar, calculamos minZoom, centramos y dibujamos
        //---------------------------------------------------
        setTimeout(() => {
            loadingScreen.style.display = "none";

            // Calculamos el zoom mínimo para que quepa todo el canvas
            minZoom = calcMinZoom();

            // Empezamos en ese nivel de zoom y centramos
            zoomLevel = minZoom;
            centerCanvas();
            
            updateCanvas();
        }, 1000);
    });
    </script>
</body>
</html>
