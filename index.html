<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas Colaborativo de Píxeles</title>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; font-family: Arial, sans-serif; background-color: #f0f0f0; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; overflow: hidden; }
        #pixel-canvas { background-color: white; }
        #color-palette, #controls, #coordinates, #minimap { position: fixed; background-color: white; padding: 10px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1); z-index: 100; }
        #color-palette { top: 20px; left: 20px; display: flex; flex-wrap: wrap; gap: 8px; }
        .color { width: 25px; height: 25px; cursor: pointer; border-radius: 4px; border: 2px solid transparent; }
        .color.selected { border: 2px solid #333; }
        #controls { top: 20px; right: 20px; display: flex; flex-direction: column; gap: 10px; }
        button { padding: 8px 12px; background-color: #4CAF50; color: white; border: none; cursor: pointer; }
        button:hover { background-color: #45a049; }
        #minimap { bottom: 20px; left: 20px; width: 150px; height: 150px; }
        #viewport-indicator { position: absolute; border: 2px solid red; pointer-events: none; }
        #loading { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background-color: rgba(255, 255, 255, 0.9); display: flex; justify-content: center; align-items: center; z-index: 1000; }
        .spinner { border: 5px solid #f3f3f3; border-top: 5px solid #3498db; border-radius: 50%; width: 50px; height: 50px; animation: spin 2s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        /* Sección color-picker */
        #color-palette {
            position: fixed;
            top: 20px;
            left: 20px;
            background: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            width: 250px;
            z-index: 100;
        }
        #color-picker {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
        }
        #color-input {
            width: 40px;
            height: 40px;
            border: none;
            background: none;
            cursor: pointer;
        }
        #color-hex {
            width: 80px;
            padding: 5px;
            font-size: 14px;
            text-align: center;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        #color-slider-container {
            margin-bottom: 10px;
        }
        #color-slider {
            width: 100%;
            appearance: none;
            height: 5px;
            background: linear-gradient(to right, black, white);
            border-radius: 5px;
            outline: none;
            transition: opacity 0.2s;
        }
        #preset-colors {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }
        .color {
            width: 30px;
            height: 30px;
            border-radius: 4px;
            border: 2px solid transparent;
            cursor: pointer;
        }
        .color.selected {
            border: 2px solid #333;
        }
    </style>
</head>
<body>
    <div id="loading">
        <div class="spinner"></div>
        <p>Cargando canvas gigante...</p>
    </div>
    <div id="canvas-container">
        <canvas id="pixel-canvas"></canvas>
    </div>
    <div id="color-palette">
        <div id="color-picker">
            <input type="color" id="color-input">
            <input type="text" id="color-hex" maxlength="7">
        </div>
        <div id="color-slider-container">
            <input type="range" id="color-slider" min="0" max="100" value="100">
        </div>
        <div id="preset-colors">
            <div class="color" style="background-color: #000000;" data-color="#000000"></div>
            <div class="color" style="background-color: #FF0000;" data-color="#FF0000"></div>
            <div class="color" style="background-color: #00FF00;" data-color="#00FF00"></div>
            <div class="color" style="background-color: #0000FF;" data-color="#0000FF"></div>
            <div class="color" style="background-color: #FFFF00;" data-color="#FFFF00"></div>
            <div class="color" style="background-color: #FF00FF;" data-color="#FF00FF"></div>
            <div class="color" style="background-color: #00FFFF;" data-color="#00FFFF"></div>
            <div class="color" style="background-color: #FFA500;" data-color="#FFA500"></div>
        </div>
    </div>
    <div id="controls">
        <button id="zoom-in">Zoom +</button>
        <button id="zoom-out">Zoom -</button>
        <button id="reset-view">Reset</button>
    </div>
    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const canvas = document.getElementById('pixel-canvas');
            const ctx = canvas.getContext('2d');
            const colorPalette = document.getElementById('color-palette');
            const zoomInButton = document.getElementById('zoom-in');
            const zoomOutButton = document.getElementById('zoom-out');
            const resetViewButton = document.getElementById('reset-view');
            const loadingScreen = document.getElementById('loading');

            const colorInput = document.getElementById("color-input");
            const colorHex = document.getElementById("color-hex");
            const colorSlider = document.getElementById("color-slider");
            const presetColors = document.querySelectorAll(".color");

            const CANVAS_SIZE = 5000;     // Tamaño total del canvas en píxeles
            const PIXEL_SIZE = 10;       // Tamaño de cada píxel "virtual" en pantalla
            const MAX_INDEX = CANVAS_SIZE / PIXEL_SIZE; // Para controlar que no se pinte fuera

            let zoomLevel = 1;
            let offsetX = 0;
            let offsetY = 0;
            let selectedColor = "#000000";
            let pixels = {};

            // Para el arrastre
            let isDragging = false;
            let lastMouseX = 0, lastMouseY = 0;

            // Datos para manejo HSL
            let baseHSL = { h: 0, s: 0, l: 50 }; // Color base en HSL

            canvas.width = CANVAS_SIZE;
            canvas.height = CANVAS_SIZE;

            /************ Conversión HEX <-> HSL ************/
            function hexToHSL(hex) {
                let r = parseInt(hex.substring(1, 3), 16) / 255;
                let g = parseInt(hex.substring(3, 5), 16) / 255;
                let b = parseInt(hex.substring(5, 7), 16) / 255;

                let max = Math.max(r, g, b), min = Math.min(r, g, b);
                let h, s, l = (max + min) / 2;

                if (max === min) {
                    h = s = 0;
                } else {
                    let d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    switch (max) {
                        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                        case g: h = (b - r) / d + 2; break;
                        case b: h = (r - g) / d + 4; break;
                    }
                    h = Math.round(h * 60);
                }
                return { h, s: Math.round(s * 100), l: Math.round(l * 100) };
            }

            function hslToHex(h, s, l) {
                s /= 100;
                l /= 100;
                let c = (1 - Math.abs(2 * l - 1)) * s;
                let x = c * (1 - Math.abs((h / 60) % 2 - 1));
                let m = l - c / 2;
                let r, g, b;

                if (0 <= h && h < 60) { r = c; g = x; b = 0; }
                else if (60 <= h && h < 120) { r = x; g = c; b = 0; }
                else if (120 <= h && h < 180) { r = 0; g = c; b = x; }
                else if (180 <= h && h < 240) { r = 0; g = x; b = c; }
                else if (240 <= h && h < 300) { r = x; g = 0; b = c; }
                else { r = c; g = 0; b = x; }

                return `#${((1 << 24) + ((Math.round((r + m) * 255) << 16)) + ((Math.round((g + m) * 255) << 8)) + Math.round((b + m) * 255)).toString(16).slice(1).toUpperCase()}`;
            }
            /************************************************/

            function drawGrid() {
                ctx.strokeStyle = "#ddd";
                for (let x = 0; x < CANVAS_SIZE; x += PIXEL_SIZE) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, CANVAS_SIZE);
                    ctx.stroke();
                }
                for (let y = 0; y < CANVAS_SIZE; y += PIXEL_SIZE) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(CANVAS_SIZE, y);
                    ctx.stroke();
                }
            }

            function updateCanvas() {
                // Reinicia la transformación
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Aplica traslación y escalado
                ctx.translate(offsetX, offsetY);
                ctx.scale(zoomLevel, zoomLevel);

                // Dibuja la cuadrícula
                drawGrid();

                // Dibuja cada píxel guardado en 'pixels'
                for (const key in pixels) {
                    const [px, py] = key.split(',').map(Number);
                    ctx.fillStyle = pixels[key];
                    ctx.fillRect(px * PIXEL_SIZE, py * PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE);
                }
            }

            /************ Manejo de color y brillo ************/
            function updateSelectedColor(color) {
                selectedColor = color;
                baseHSL = hexToHSL(color);
                applyBrightness();
                colorInput.value = color;
                colorHex.value = color.toUpperCase();
                document.querySelector(".color.selected")?.classList.remove("selected");
            }

            function applyBrightness() {
                const newColor = hslToHex(baseHSL.h, baseHSL.s, colorSlider.value);
                colorInput.value = newColor;
                colorHex.value = newColor.toUpperCase();
                selectedColor = newColor;
            }

            colorInput.addEventListener("input", (e) => updateSelectedColor(e.target.value));
            
            colorHex.addEventListener("input", (e) => {
                if (/^#[0-9A-F]{6}$/i.test(e.target.value)) {
                    updateSelectedColor(e.target.value);
                }
            });

            presetColors.forEach(colorDiv => {
                colorDiv.addEventListener("click", () => {
                    updateSelectedColor(colorDiv.getAttribute("data-color"));
                    colorDiv.classList.add("selected");
                });
            });

            colorSlider.addEventListener("input", applyBrightness);
            // Color inicial por defecto
            updateSelectedColor("#000000");
            /*************************************************/


            /************ Eventos de dibujo ************/
            // Impide que se dibuje si estamos arrastrando
            // y evita pintar fuera del canvas
            canvas.addEventListener("click", function (e) {
                // Si está arrastrando el mouse, no dibuja
                if (isDragging) return;

                const rect = canvas.getBoundingClientRect();
                // Calcula coordenadas en el espacio del "canvas" escalado
                const x = Math.floor((e.clientX - rect.left - offsetX) / (zoomLevel * PIXEL_SIZE));
                const y = Math.floor((e.clientY - rect.top - offsetY) / (zoomLevel * PIXEL_SIZE));

                // Verifica que la posición esté dentro del rango [0..MAX_INDEX-1]
                if (x < 0 || x >= MAX_INDEX || y < 0 || y >= MAX_INDEX) {
                    return; // Fuera de rango, no dibuja
                }

                // Asigna el color elegido
                pixels[`${x},${y}`] = selectedColor;
                updateCanvas();
            });

            /************ Eventos de zoom ************/
            zoomInButton.addEventListener("click", function () {
                zoomLevel = Math.min(zoomLevel * 1.2, 10);
                updateCanvas();
            });

            zoomOutButton.addEventListener("click", function () {
                zoomLevel = Math.max(zoomLevel / 1.2, 0.1);
                updateCanvas();
            });

            resetViewButton.addEventListener("click", function () {
                zoomLevel = 1;
                offsetX = 0;
                offsetY = 0;
                updateCanvas();
            });

            canvas.addEventListener("wheel", function (event) {
                event.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;
                const canvasX = (mouseX - offsetX) / zoomLevel;
                const canvasY = (mouseY - offsetY) / zoomLevel;

                zoomLevel *= event.deltaY < 0 ? 1.1 : 0.9;
                offsetX = mouseX - canvasX * zoomLevel;
                offsetY = mouseY - canvasY * zoomLevel;

                updateCanvas();
            });

            /************ Eventos de arrastre ************/
            canvas.addEventListener("mousedown", function (event) {
                // Solo arrastramos con el botón izquierdo
                if (event.button === 0) {
                    isDragging = true;
                    lastMouseX = event.clientX;
                    lastMouseY = event.clientY;
                    canvas.style.cursor = "grabbing";
                }
            });

            canvas.addEventListener("mousemove", function (event) {
                if (isDragging) {
                    let dx = event.clientX - lastMouseX;
                    let dy = event.clientY - lastMouseY;

                    offsetX += dx;
                    offsetY += dy;

                    lastMouseX = event.clientX;
                    lastMouseY = event.clientY;

                    // Redibuja el canvas con la nueva posición
                    updateCanvas();
                }
            });

            canvas.addEventListener("mouseup", function () {
                isDragging = false;
                canvas.style.cursor = "default";
            });

            canvas.addEventListener("mouseleave", function () {
                isDragging = false;
            });

            /************ Oculta el loading y dibuja ************/
            setTimeout(() => {
                loadingScreen.style.display = "none";
                updateCanvas();
            }, 1000);
        });
    </script>
</body>
</html>
